---
title: "Pythonプログラマが30分でわかるR"
author: "Zettsu Tatsuya"
date: '`r format(Sys.time(), "%Y/%m/%d")`'
output:
  html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc_collapsed: true
  pdf_document:
    latex_engine: xelatex
  beamer_presentation:
    pandoc_args:
    - --latex-engine
    - xelatex
always_allow_html: true
header-includes:
  \usepackage{float}
documentclass: bxjsarticle
classoption: xelatex,ja=standard
urlcolor: blue
---

```{r get_format_table, include=FALSE}
output_format <- knitr::opts_knit$get("rmarkdown.pandoc.to")
if (output_format == "gfm-yaml_metadata_block") {
  output_format <- "gfm"
}

is_html <- (output_format == "html")
```

```{r code_background_color, results="asis", eval=is_html, echo=FALSE}
cat('<style type="text/css" rel="stylesheet">\n.python { background-color: lavender }\n.r { background-color: seashell }\n.python-output { background-color: #ececec }\n.r-output { background-color: #f9f9f9 }\n</style>\n')
```

```{r setup_packages, eval=FALSE, echo=FALSE}
Sys.setlocale("LC_ALL", "ja_JP.UTF-8")
## knitではなく各コードチャンクを逐次実行するときは、以下を実行する
install.packages("tidyverse")
install.packages("assertthat")
install.packages("cloc", repos = c("https://cinc.rud.is", "https://cloud.r-project.org/"))
install.packages("extrafont")
install.packages("functional")
install.packages("jsonlite")
install.packages("kableExtra")
install.packages("lubridate")
install.packages("plotly")
install.packages("R6")
install.packages("RColorBrewer")
install.packages("reticulate")
install.packages("rlang")

## ドキュメント作成とコード整形
## Rパッケージ(knitr, xfun) と pandocは、rocker/tidyverse に入っている
install.packages("knitr")
install.packages("lintr")
install.packages("markdown")
install.packages("styler")
install.packages("xfun")
```

```{r setup_r_packages, include=FALSE}
## knitrで使うパッケージ
library(kableExtra)
library(reticulate)
library(xfun)
## 必要ならpython3にパスを通す
## reticulate::use_python("/usr/bin/python3.8")
```

```{r format_table, include=FALSE}
to_embedded_table <- function(df) {
  if (output_format == "gfm") {
    df %>%
      kable("pipe")
  } else {
    df %>%
      kable() %>%
      kable_styling()
  }
}
```

## 準備

本文書の [GitHubレポジトリ](https://github.com/zettsu-t/Rin30minutes) に、インストール手順があるのでそれに従う。

準備ができたら、以下のコードを RStudio の Console に順に入力して実行する。Rスクリプトを実行するときは、拡張 .R のファイルにコードを書いて、シェルから Rscript を起動する。

## プログラミング言語Rの基本

### 基本型

基本型としてとりあえず、論理型 (logical : Pythonのbool)、数値 (numeric)、文字列 (character) を知っておけばよい。characterは文字列で、文字型は無い。文字コードは Unicode、エンコーディングは UTF-8 一択にする。Shift_JIS はもう忘れよう。

論理型の、真は TRUE、偽は FALSE という定数である。全部大文字である。整数と真理値を足すとき、 TRUE は1に、 FALSE は0として扱う。Python の `2 + True` と、R の `2 + TRUE` はどちらも 3 になる。

まずPythonの実行結果を示す。

```{python add_int_bool_python, result="asis", class.source="python-code", class.output="python-output"}
2 + True
```

次にRの実行結果を示す。出力の先頭に `[1]` がついているが、これについては後述する。

```{r add_int_bool_r, class.source="r-code", class.output="r-output"}
2 + TRUE
```

NA (欠測値 : missing value) と、変数に対応するオブジェクトが無い (NULL) ことを区別する。変数がNAかどうかは `is.na` で、NULLかどうかは `in.null` で調べる。これらの細かい仕様は省略する。

```{r is_na, class.source="r-code", class.output="r-output"}
is.na(0)
is.na(NA)
is.null(0)
is.null(NULL)
```

一般的にNAとの計算結果はNAになる。

```{r na_integer, class.source="r-code", class.output="r-output"}
2 + NA
2 > NA
```

以下の結果は、C++の `boost::tribool` に近い。

```{r na_tribool, class.source="r-code", class.output="r-output"}
TRUE & NA
TRUE | NA
FALSE & NA
FALSE | NA
```

NAは logical, numeric, character と、それぞれの型に用意されている。実は logical → numeric → character という変換は、必要なら暗黙に行われるので、あまり気にしなくてよい。さっきの `2 + TRUE` がそうだった。

数値が NA (欠測値)、正の無限大 Inf、負の無限大 -Inf、NaN (非数 : Not a Number)であることを区別する。`is.na`, `is.infinite`, `is.nan` を使って調べる。 `==` では比較しないことに注意する。RはNAとNaNを区別するので便利である(入力値が欠測なことと、計算結果がNaNであることは別なので)。

```{r is_inf_nan, class.source="r-code", class.output="r-output"}
is.infinite(0)
is.infinite(Inf)
Inf > 0
is.infinite(-Inf)
-Inf < 0
is.nan(0)
is.nan(NaN)
```

関数の説明は、`?関数名`で得られる。RStudio の Console から `?is.na` と入力すると、 `is.na` の説明が表示される。ネットで探すよりも速い。

```{r help_is_nan, eval=FALSE, echo=TRUE, class.source="r-code", class.output="r-output"}
?is.na
```

Rにスカラー変数はない。C++の `std::vector` てきな集合、つまり型が等しい複数の要素を、インデックスで参照できる集合が、ベクトルとして用意されている。なのでスカラー変数に見えるものは、要素が1個のベクトルである。変数への代入は `<-` で行う。Getsと発音する。Pythonと同様に `=` でも代入できるが、 `<-` の方が見やすいと私は思う。

```{r assign_int, class.source="r-code", class.output="r-output"}
n <- 2
n * 3
```

複数の即値からベクトルを作るには、 `c(15, 26, 37, 48)` というように `c` を使う。c は combine の略である。ベクトルというか配列を作るのに `[]` を使うプログラミング言語が多いのでちょっと変わっているが、すぐ慣れるだろう。

```{r assign_vector, class.source="r-code", class.output="r-output"}
score_vec <- c(15, 26, 37, 48)
name_vec <- c("foo", "bar", "poi")
score_vec
name_vec
```

出力の `[1]` は、この行はベクトルの1番目から順番に表示している、という意味である。さっきから `[1]` が必ず表示されていたのは、要素が1個のベクトルを表示していたからである。要素がたくさんあるベクトルを表示すると行を折り返すので、そのときは1より大きい数字になる。

ベクトルに限らず、配列らしくインデックスがついているデータ(PandasのDataFrameてきなものも含む)の要素は、1始まりで数える。つまりベクトル `v` の先頭の要素は、 `v[1]` で読み書きする。PythonやC++は0始まりだが、Rは異なる(FortranやStanも1始まり)。

```{r vector_element, class.source="r-code", class.output="r-output"}
score_vec[1]
name_vec[2]
```

NumPy と同様、複数のインデックスを指定することもできる。

```{r vector_elements, class.source="r-code", class.output="r-output"}
score_vec[c(1, 4)]
```

負の値を指定すると、指定したインデックス以外を選ぶ。つまり除外するインデックスを指定することができる。

```{r vector_exclude_elements, class.source="r-code", class.output="r-output"}
score_vec[c(-2, -3)]
```

0を指定すると何も選ばない。PythonやC++の癖で、先頭要素を0にするとこうなる。敢えて0を含めることで条件分岐を省けることがあるかもしれない。

```{r vector_no_elements, class.source="r-code", class.output="r-output"}
score_vec[0]
```

ベクトル同士はcで結合する。

```{r concat_vectors, class.source="r-code", class.output="r-output"}
c(c(1, 2, 3), c(4, 5))
```

### 演算

Rにスカラー変数はなく、ベクトルはあるので、演算はベクトル同士の演算になる。

足し算 `c(10, 20, 30) + c(4, 5, 6)` は、要素ごとの和になる。これは要素が1個のベクトル `10 + 4 = 14` の拡張と考えれば素直だろう。

```{r add_vectors, class.source="r-code", class.output="r-output"}
c(10, 20, 30) + c(4, 5, 6)
10 + 4
```

`max` は、ベクトルの要素のうち、もっとも大きい値を返す。 `max(c(10, 20, 30))` は `c(30)` 、つまり要素が1個のベクトルである。さっきの足し算が map なら、 `max` は reduce と考えると解りやすいだろう。

```{r max_vector, class.source="r-code", class.output="r-output"}
max(c(10, 20, 30))
```

2つのベクトルの要素ごとの max を取りたい、つまり map したいなら、 `pmax` を使う。

```{r pmax_vectors, class.source="r-code", class.output="r-output"}
pmax(c(10, 2, 30), c(4, 50, 6))
```

NumPy てきな broadcasting を、Rでも行うことができる。 `c(10, 20, 30) + 4` は `c(14, 24, 34)` になる。左辺のそれぞれに4を足すというふるまいは直観的だろう。実際には右辺ベクトルの要素を、左辺ベクトルの要素数と同じになるまで繰り返している (repeatという)。

```{r add_vector_int, class.source="r-code", class.output="r-output"}
c(10, 20, 30) + 4
```

ちなみに同じ値を繰り返したければ、 `rep` を使う。

```{r repeat_vector_int, class.source="r-code", class.output="r-output"}
rep(4, 3)
```

### Assertion

Pythonでは、 `()` をつけずに assert を書く。

```{python assert_python, result="asis", class.source="python-code", class.output="python-output"}
assert 2 ** 4 == 16
```

```{python assertion_failed_python, error=TRUE, result="asis", class.source="python-code", class.output="python-output"}
assert 2 ** 4 != 16
```

Rでは assertthat を使う。パッケージを使う前に import するのは、Pythonと同様である。

```{r library_assert_r, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
library(assertthat)
```

```{r assert_r, class.source="r-code", class.output="r-output"}
assertthat::assert_that((2**4) == 16)
```

```{r assertion_failed_r, error=TRUE, class.source="r-code", class.output="r-output"}
assertthat::assert_that((2**4) != 16)
```

### ベクトルの要素数とrange

要素数は `NROW` で調べる。 `length` もあるが忘れていい。

```{r length_vector_int, class.source="r-code", class.output="r-output"}
NROW(c(10, 20, 30))
NROW(4)
NROW(c())
```

Python の `range` てきな連番を作ろう。要素数n個のベクトルvに対して 1, 2, ..., n という連番の整数は、 `seq_len(n)` で作る。

```{r seq_len_basic, class.source="r-code", class.output="r-output"}
seq_len(3)
```

`1:3` とも書ける。

```{r seq_len_vector_colon, class.source="r-code", class.output="r-output"}
1:3
```

`seq_len(NROW())` でベクトルのインデックスを作れる。`seq_len(NROW(c(10, 20, 30)))` は要素が3個なので `c(1, 2, 3)` になる。 `seq_len(NROW(c()))` は空ベクトルが返る。

```{r seq_len_vector_int, class.source="r-code", class.output="r-output"}
seq_len(NROW(c(10, 20, 30)))
seq_len(NROW(c()))
```

続きは[等差数列](#number_sequence)の項で説明する。

### リスト

型が混在する集合は list に格納する。Pythonの list やC言語の構造体と似ている。以下のコードに "" (二重引用符) が無い箇所があることに注意する。

```{r list, class.source="r-code", class.output="r-output"}
a_lst <- list(name = "foo", score = 80, year = 2019)
a_lst
NROW(a_lst)
names(a_lst)
```

要素には `$属性名` 、 `[[属性名]]` 、インデックスでアクセスできる。Pythonのenumerableな感じだ。

```{r list_elements, class.source="r-code", class.output="r-output"}
a_lst$score
a_lst[["score"]]
a_lst[[2]]
```

一重カッコ `[属性名]` は、要素ではなくリストを返す。 `is.list` はオブジェクトがリストかどうか返す。

```{r sublist, class.source="r-code", class.output="r-output"}
a_lst["score"]
a_lst[2]
is.list(a_lst["score"])
is.list(a_lst[["score"]])
```

ベクトルと同様に、インデックスを指定して部分リストを得ることができる。属性名を指定してもよい。

```{r sublists, class.source="r-code", class.output="r-output"}
a_lst[c(1, 2)]
a_lst[c("name", "score")]
```

リスト同士はcで結合する。Pythonもそうだが、リストを長くするのか、リストにリストを入れて入れ子にするのかで、コードを使い分ける必要がある。

こちらはリストを長くする。

```{r concat_lists, class.source="r-code", class.output="r-output"}
list_1 <- list("foo")
list_2 <- list(80)
list_3 <- list(2019)
list_3_elements <- c(list_1, list_2, list_3)
list_3_elements
NROW(list_3_elements)
```

こちらはリストを入れ子にする。

```{r nested_lists, class.source="r-code", class.output="r-output"}
nested_list <- list(first = list_1, second = list_2)
nested_list
```

要素の型がすべて同じリストは、 `unlist` でベクトルに変換することができる。逆も然りで、 `as.list` を使ってベクトルをリストにする。後で説明するが、Rでは一般的に `as.型名` で型変換を行う。

`identical` は、二つのオブジェクトが同値ならTRUE、違っていたらFALSEを返す。identicalといいつつ、同一オブジェクト(雑に言うと同じメモリ番地に置かれている)かどうかではなく、値が同じかどうかを調べる。

```{r vectors_from_to_lists, class.source="r-code", class.output="r-output"}
original_vec <- 1:5
list_from_vec <- as.list(original_vec)
converted_vec <- unlist(list_from_vec)
assertthat::assert_that(identical(original_vec, converted_vec))
```

### DataFrame (tibble)

```{r import_tidyverse, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
library(tidyverse)
```

Pandas の DataFrame と同様に、Rにも data.frame がある (Rが先だったかもしれないが)。だが tibble の方が便利なのでそちらを使う。まず説明用の架空データを作る。

```{r create_tibble, class.source="r-code", class.output="r-output"}
df <- tibble(name = c("foo", "bar"), score = c(80, 60), year = c(2019, 2020))
```

```{r embed_tibble, eval=TRUE, echo=FALSE, class.source="r-code", class.output="r-output"}
to_embedded_table(df)
```

変数を `print` すると今作った tibble を文字列として表示する。というより実は、変数名だけ入力すると `print` して表示していたのだった。Python の REPL と同じである。

```{r print_tibble, class.source="r-code", class.output="r-output"}
print(df)
```

`View` するとExcelっぽいウィンドウに表示する。ここには表示できないので、各自試してほしい。

```{r view_tibble, eval=FALSE, echo=TRUE, class.source="r-code", class.output="r-output"}
View(df)
```

tibble は、縦に標本を並べ、横に標本の属性を並べる。ざっくりいうと、縦に長いベクトル=すべての標本についてのそれぞれの属性を、横にいろいろと並べたものがtibbleと思えばよい。なので、先のリストの動作がそのまま当てはまる。

まず score のベクトルを取得する。Pandas がそうであるように、tibble は連想配列らしく使える。ベクトルが返るので Pandas の Series とは少し異なる。

```{r extract_column_as_vector, class.source="r-code", class.output="r-output"}
df$score
df[["score"]]
df[[2]]
```

score列だけを切り出した tibble を取得する。

```{r extract_column_as_tibble, class.source="r-code", class.output="r-output"}
df["score"]
df[2]
```

行=標本も指定しよう。この記法は NumPy っぽく、Pandas のように `loc` とは書かない。

```{r extract_cell, class.source="r-code", class.output="r-output"}
df[[1, "score"]]
df[1, "score"]
```

行=標本を指定して全属性を取り出すときは、 `,` の後を空白にする。Pandasのように `:` は書かない。

```{r extract_sample, class.source="r-code", class.output="r-output"}
df[1, ]
```

ここでは一列ずつ、一行ずつ取り出したが、リストと同様に複数の要素を取り出すこともできる。


### Matrix

Matrix は tibble に比べれば覚えることが少ないので、最低限のことだけ説明する。

tibble と異なり、すべての要素を同じ型にする。まずベクトルから行列を作る。 `byrow` で並べ方を指定する。

```{r create_matrices, class.source="r-code", class.output="r-output"}
matrix(data = 1:6, nrow = 2, byrow = FALSE)
matrix(data = 1:6, nrow = 2, byrow = TRUE)
```

要素がすべて型の同じ tibble から行列を作る。

```{r tibble_to_matrix, class.source="r-code", class.output="r-output"}
df_num <- tibble(p = 1:2, q = 3:4, r = 5:6)
mat_num <- as.matrix(df_num)
mat_num
```

as_tibbleでtibbleに変換する。

```{r matrix_to_tibble, class.source="r-code", class.output="r-output"}
df_mat_num <- as_tibble(mat_num)
df_mat_num
assertthat::assert_that(identical(df_num, df_mat_num))
```

演算、転置、3次元以上の配列 (array) の生成などはもちろんできるので、必要になったら調べればよい。

### 関数

Rの関数は、Pythonのラムダ式である。

Pythonでは以下のように、引数の2乗を返す無名関数を定義して、それを my_square という変数に格納し、こう呼び出せる。

```{python lambda_python, result="asis", class.source="python-code", class.output="python-output"}
my_square = lambda n: n * n
my_square(9)
```

Rでは `function` と書く。

```{r lambda_r, class.source="r-code", class.output="r-output"}
my_square <- function(n) {
  n * n
}
my_square(9)
```

Pythonと同様に、引数にキーワードをつけてもよい。引数が多いときは、キーワードをつけるとソースコードが読みやすく保守しやすくなるだろう。

```{r keyword_parameters, class.source="r-code", class.output="r-output"}
my_square(n = 9)
```

Pythonと同様に、引数のキーワードありとなしを混在することもできる。まずキーワードがある引数を当てはめ、残りのパラメータをまだ値が無い先頭のパラメータから順に当てはめる。

```{r named_parameters, class.source="r-code", class.output="r-output"}
my_pow <- function(base, index) {
  base**index
}
my_pow(index = 2, 3)
```

`do.call` を使って、Pythonのunpack, Rubyのsplatのように、listを引数に展開することもできる。

```{r splat_parameters, class.source="r-code", class.output="r-output"}
args <- list(base = 3, index = 2)
do.call(my_pow, args)
```

さて、Rの関数はすべて式(expression)である。関数が最後に評価したこと(雑に言うと `{}` 内の最後の行)が関数の返り値になる。関数定義の途中で処理を終えるのでなければ、 `return` と明示する必要ない(この辺はRubyっぽい)。

Rで負の数の対数を取ると、警告を出してNaNを返すが、代わりに-Infを返す関数を作ろう。ifも式なのでこう書ける。

```{r if_expression, class.source="r-code", class.output="r-output"}
my_log10 <- function(x) {
  if (x <= 0) {
    -Inf
  } else {
    log10(x)
  }
}

log10(-1)
my_log10(-1)
my_log10(0)
my_log10(0.1)
my_log10(10)
```

最初に述べた通り、Rにスカラー変数はないので、この引数xはベクトルである。ならば、ベクトルを受け取ってベクトルを返すmap動作がRらしいだろう。Pythonの Pythonic に対応する言葉が、R-like である。上記のコードがどうなるか試してみよう。

```{r naive_my_log, class.source="r-code", class.output="r-output"}
my_log10(c(-1, 0, 0.1, 10))
```

上手くいってないようだ。改善方法は二つある。一つ目の方法は、 `if` ではなく `ifelse` を使って、ベクトルの要素ごとにthenな値とelseな値を選ぶことだ。ただしこれは、log10(負の値)が警告を出すので、見た目がよろしくない。警告ではなくエラーになる関数では使えないだろう。

```{r if_else_log, class.source="r-code", class.output="r-output"}
my_log10_alt1 <- function(xs) {
  ifelse(xs <= 0, -Inf, log10(xs))
}
my_log10_alt1(c(-1, 0, 0.1, 10))
```

二つ目の方法は、Pythonの list comprehension てきにmapすることだ。このようにmapを使いこなすとよいだろう。 `purrr::map_dbl` は要素が数値のベクトルを返す。

```{r map_else_log, class.source="r-code", class.output="r-output"}
my_log10_alt2 <- function(xs) {
  purrr::map_dbl(xs, function(x) {
    if (x <= 0) {
      -Inf
    } else {
      log10(x)
    }
  })
}
my_log10_alt2(c(-1, 0, 0.1, 10))
```

Rでfor文は使わないので、忘れてよい。Pythonでfor文を使う処理があったら、常にmapとreduceを使うことを検討しよう。mapの例の次に、reduceの使い方としてフィボナッチ数列を示そう。0と負の数についてはエラーになるが、それでいいだろう。

```{r reduce_fib, class.source="r-code", class.output="r-output"}
my_fib <- function(xs) {
  purrr::map_dbl(xs, function(x) {
    tail(purrr::reduce(.x = seq_len(x), .init = integer(), function(acc, i) {
      if (i == 1) {
        c(1)
      } else if (i == 2) {
        c(1, 1)
      } else {
        c(acc[2], sum(acc))
      }
    }), 1)
  })
}

my_fib(1:10)
```

Pythonで外の lexical scope にある変数を変更するには、`nonlocal` を使う。以下のコードでは、`outer()` 呼び出しは1を返す。

```{python nonlocal_python, result="asis", class.source="python-code", class.output="python-output"}
def outer():
  z = 0
  def inner():
     nonlocal z
     z = z + 1
     return -2
  inner()
  return z

outer()
```

Rでは `<<-` を使って、 lexical scope の外にある変数に代入する。

```{r nonlocal_r, class.source="r-code", class.output="r-output"}
outer <- function() {
  z <- 0
  inner <- function() {
    z <<- z + 1
    -2
  }
  inner()
  z
}

outer()
```

PythonもRも、lexical scopeの範囲は、細かい説明を省いてざっくりいうと関数(defやfunction)である。なので関数が入れ子になっている場合は、nonlocalが必要になることがある。C++は `if (cond) {}` や何もキーワードがつかない `{}` も自動変数の範囲と寿命を決めているが、Rはそうではないので注意する(つまり `if` などは lexical scope を変えない)。

## いろいろな処理と込み入った話題

### 文字列処理

Rでは文字列の整形をするには、昔ながらの `sprintf` を使う。

```{r sprintf, class.source="r-code", class.output="r-output"}
sprintf("地点=%s, 温度=%.1f", "横浜", 11.8)
```

文字列を連結するときは、 `paste` を使う。 `sep` 引数が文字列の区切り文字で、デフォルトは半角空白1個である。英語で英単語を連結して文を作るときはこれでよいが、日本語では困ることがあるだろう。区切り文字を空文字列にするには `sep` 引数で明示的に指定するか、 `paste0` を使う。Rの文字列は `+` 演算子で連結できない。

```{r paste, class.source="r-code", class.output="r-output"}
paste("神奈川県", "横浜市", "中区")
paste("神奈川県", "横浜市", "中区", sep = " ")
paste0("神奈川県", "横浜市", "中区")
paste("神奈川県", "横浜市", "中区", sep = ":")
```

以下のコードは意外にも、要素が3個のベクトルを返す。 `paste` はベクトルをベクトルに map する関数である。

```{r paste_map, class.source="r-code", class.output="r-output"}
words <- c("神奈川県", "横浜市", "中区")
paste(words)
```

`collapse` を指定すると、文字列を区切り文字で連結 (join) して、単一の文字列を返す reduce な動作になる。

```{r paste_reduce, class.source="r-code", class.output="r-output"}
paste(words, sep = "", collapse = ":")
```

より高度な文字列処理は stringrパッケージを使う。PythonもRもたくさんの関数があるが、代表的なものとして正規表現で文字列を分解する例を示そう。Python の reモジュールは full matching 、R の stringrパッケージは partial matching である。

```{python str_match_pythoon, eval=TRUE, result="asis", class.source="python-code", class.output="python-output"}
import re
re.match(r".{2}(\D+)(\d+)", "01Year2022").groups()
```

```{r str_match_r, class.source="r-code", class.output="r-output"}
stringr::str_match("01Year2022", "(\\D+)(\\d+)")
```

### 強制型変換

既に書いたが、logical, numeric, character の右側への変換は、必要なら暗黙に行われる。 `paste` 関数で試そう。書式を指定しなければ、よきに計らった文字列表記になる。

```{r coerce_paste, class.source="r-code", class.output="r-output"}
paste("Text", exp(1), 2, FALSE)
```

リストとベクタの変換で既に示したように、型変換は一般に `as.型名` でできる。Rは変数名に `.` を含めることができ、PythonやC++でインスタンスメソッドの前に . をつけるときのような特別な意味は . にはない。

```{r coerce_numeric, class.source="r-code", class.output="r-output"}
as.numeric("-2.7")
as.integer("-2.7")
as.character(-2.7)
```

無限大と文字列に書くことができる。Pythonの `float()` 呼び出しと同じである。こちらがPythonで

```{python coerce_inf_python, class.source="python-code", class.output="python-output"}
float("Inf")
float("-infinity")
```

こちらがRである。

```{r coerce_inf_r, class.source="r-code", class.output="r-output"}
as.numeric("Inf")
as.numeric("-infinity")
```

型変換できないときは、警告を出してNAが返る。Pythonと違って、エラーにはならない。

```{python coerce_not_a_number_python, error=TRUE, class.source="python-code", class.output="python-output"}
float("abc")
```

```{r coerce_not_a_number_r, class.source="r-code", class.output="r-output"}
as.numeric("abc")
```

NAは後でどうにかするので警告を無視したいなら、 `suppressWarnings` を使う。

```{r suppress_warnings, class.source="r-code", class.output="r-output"}
suppressWarnings(as.numeric("abc"))
```

### 等差数列 {#number_sequence}

Pythonの `range` と同様のことをしたければ、Rには `seq` とか `1:n` とかがある。Pythonと異なりRは閉区間であり、区間の開始と終了の両方を要素に含む。また、開始番号が終了番号より小さいと、1ずつ減る数列が得られる。ベクトルのインデックスを得る場合に、これだと空のベクトルのインデックスが `c(1, 0)` になってまずい。 `seq_len` を積極的に使おう。

```{r seq_vector, error=TRUE, class.source="r-code", class.output="r-output"}
seq(4)
1:4
seq_len(4)
seq(0)
1:0
seq_len(0)
seq(-2)
1:-2
seq_len(-2)
```

さて差が整数ではない等差数列は、丸め誤差が発生するので、予想した長さにならないことがある。以下はPythonのコードである。 `NumPy.linspace` は数列の長さを指定するので正しい個数になるが、 `NumPy.arrange` は丸め誤差の影響で個数が合わないことがある。

```{python linspace_python, class.source="python-code", class.output="python-output"}
import numpy as np
for x in range(50, 53):
  print("{} {}".format(len(np.linspace(0.0, 1.0, x)),
                       len(np.arange(0.0, 1.0, 1.0/(x - 1)))))
```

同様のことを、Rでは `seq` の `length.out` 引数と、 `by` 引数で区別する。この例ではPythonと違って丸め誤差の影響を受けなかったが、両引数を使い分ける必要がある。

```{r linspace_r, class.source="r-code", class.output="r-output"}
purrr::map_chr(50:52, function(x) {
  sprintf(
    "%d %d", NROW(seq(from = 0.0, to = 1.0, length.out = x)),
    NROW(seq(from = 0.0, to = 1.0, by = 1.0 / (x - 1)))
  )
})
```

これまで明言しなかったが、関数呼び出しの結果や、変数を評価した結果はコンソールに表示される。そのままだと大量の出力でコンソールが埋まって困ることがあるだろう。関数の結果を変数で受け止めるのが一つの方法だが、もう一つの方法は関数呼び出しの結果を `invisible` で受け止めることである。

いかにもわざとらしい例だが、以下の例は `invisible` があると何も表示しないし、 `invisible` がなければ最大20000個(通常は1000個で打ち切り)を表示しようとする。

```{r launch_invisible, class.source="r-code", class.output="r-output"}
invisible(1:20000)
```

### 日時と時刻

日時(date)と時刻(timestamp)を上手く扱うのは難しいので、よくできたパッケージを上手に使いこなす。一年の初めからどれだけの割合(0以上1以下)が経過したか指定すると、その日時を表示する関数を作る。うるう年は考慮するがうるう秒は考慮しない。あるツイートにあった、[1月4日のお昼には、もう2021年の「1%」が経過している](https://twitter.com/kuina_ch/status/1344513191707963392)のは本当だろうか?

```{r library_lubridate, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
library(lubridate)
```

```{r elapsed_time_in_year, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
elapsed_time_in_year <- function(year, ratio) {
  epoch <- paste0(year, "-01-01 00:00:00")
  x <- lubridate::ymd_hms(epoch, tz = "Asia/Tokyo")
  x + lubridate::dseconds((365 + lubridate::leap_year(x)) * 24 * 60 * 60 * ratio)
}

elapsed_time_in_year(year = 2021, ratio = 0.01)
elapsed_time_in_year(year = 2020, ratio = 0.01)
elapsed_time_in_year(year = 2021, ratio = 0.162)
elapsed_time_in_year(year = 2020, ratio = 0.162)
```

時間 (duration)を説明するついでに関数合成しよう。 `functional::Compose` は二つの関数を合成する。ここでは `hh:mm:ss` 書式の時間の文字列を受け取って、何秒か返す関数を作る。 `function` を使っても同じことをできるが、引数を書かなくて済むのですっきりする。

```{r hms_to_seconds, class.source="r-code", class.output="r-output"}
library(functional)
hms_to_seconds <- functional::Compose(lubridate::hms, lubridate::seconds)
```

```{r launch_hms_to_seconds, class.source="r-code", class.output="r-output"}
hms_to_seconds("00:01:04")
hms_to_seconds("01:00:04")
```

### クラス

PythonやC++てきなクラス、つまりクラスにメンバ関数とメンバ変数を定義したデータ構造をRでも作れる。まずPythonでカウンターを作る例を示す。

```{python counter_class_python, result="asis", class.source="python-code", class.output="python-output"}
class Counter:
    """A classic example of classes"""
    __count = 0

    def __init__(self):
        """Initialize member variable(s)"""
        self.__count = 0

    def increment(self):
        """Increment the count"""
        self.__count = self.__count + 1

    def get(self):
        """Get the count"""
        return self.__count

ct = Counter()
print(ct.get())
ct.increment()
ct.increment()
print(ct.get())
```

Rでは R6パッケージを使う。ほぼPythonと同様に書ける。public, private と明記するところがC++みたいだ。

```{r counter_class_r6, class.source="r-code", class.output="r-output"}
library(R6)

Counter <- R6::R6Class("Counter",
  public = list(
    # Initialize member variable(s)
    initialize = function() {
      private$count <- 0
    },

    # Increment the count
    increment = function() {
      private$count <- private$count + 1
    },

    # Get the count
    get = function() {
      private$count
    }
  ),
  private = list(
    count = 0
  )
)

ct <- Counter$new()
print(ct$get())
ct$increment()
ct$increment()
print(ct$get())
```

### 参照渡しと copy-on-modify

Rでは、呼び出された関数は引数を変更できるが、その変更は呼び出し側には伝わらない(そうでない場合についてはすぐ後で述べる)。これはPythonとの大きな違いである。より正確に言うと、引数を変更すると copy-on-modify される。引数を変更しなければコピーするコストが発生しないので、実質的には低コストな参照渡しのように動作する。

Pythonで、配列の要素をすべて2倍にするとき、こう書ける。

```{python double_python, class.source="python-code", class.output="python-output"}
import numpy as np

def doubler(x):
  for i, item in enumerate(x):
    x[i] = item * 2
  print(np.sum(x))
  assert np.sum(x) == 20

v = np.ones(10)
doubler(v)
v
```

Rで同様のコードを書くとどうなるだろうか? 忘れていたfor文を敢えて使って書こう。

```{r double_for_r, class.source="r-code", class.output="r-output"}
doubler <- function(x) {
  for (i in seq_len(NROW(x))) {
    x[i] <- x[i] * 2
  }
  print(sum(x))
  assertthat::assert_that(sum(x) == 20)
}

v <- rep(1, 10)
doubler(v)
v
```

doubler の中では二倍になったようだが(和が20なので)、呼び出し元の変数vは変わらなかった。これが copy-on-modify である。

Rでは引数を上書きすることは諦めて、値を返す関数を素直にmapで書こう。 `~ .x * 2` は無名関数の略記法である。今は深入りしないが、いずれ役に立つことがあるだろう。

```{r double_map_r, class.source="r-code", class.output="r-output"}
doubler <- function(x) {
  purrr::map_dbl(x, ~ .x * 2)
}

doubler(rep(1, 10))
```

クラスのインスタンス(R6オブジェクト)は参照渡しである。呼び出された関数が引数に変更を加えると、引数を渡した呼び出し側にも変更が反映される。

```{r call_by_reference_r6, class.source="r-code", class.output="r-output"}
increment_in_callee <- function(obj) {
  obj$increment()
  print(obj$get())
}

ct_caller <- Counter$new()
invisible(increment_in_callee(ct_caller))
print(ct_caller$get())
```

Pythonも参照渡しなので、参照渡しの方がなじみがあるだろう。

```{python call_by_reference_python, result="asis", class.source="python-code", class.output="python-output"}
def increment_in_callee(obj):
    obj.increment()
    print(obj.get())

ct_caller = Counter()
increment_in_callee(ct_caller)
print(ct_caller.get())
```

### デフォルト値

Pythonで関数呼び出しに失敗した場合にデフォルト値を得ようとしたら、try-except構文を使うだろう。

```{python possibly_python, result="asis", class.source="python-code", class.output="python-output"}
import math
def str_to_float(x: str) -> float:
  value = math.nan
  try:
    value = float(x)
  except ValueError:
    pass
  return(value)

math.isnan(str_to_float("1.25"))
math.isnan(str_to_float("x.y.z"))
```

Rでは `purrr::possibly` を使って、デフォルト値を返す関数を作る。 `stop` はエラーを発生させる関数である。

```{r possibly_r, error=TRUE, class.source="r-code", class.output="r-output"}
func_may_unsupported <- function(x) {
  stop("Unsupported")
}

safe_func <- purrr::possibly(func_may_unsupported, NA)
safe_func(1)
```

変数が存在するかどうかは、Pythonでは、 `locals` と `globals` で調べると分かる。

```{python check_vars_python, result="asis", class.source="python-code", class.output="python-output"}
a_glogal_var = 1
def check_vars_exists():
  a_local_var = 2
  assert "a_glogal_var" in globals()
  assert "a_local_var" in locals()
  assert "missing_var" not in locals()

check_vars_exists()
```

Rでは `exists` で分かる。

```{r check_vars_r, class.source="r-code", class.output="r-output"}
a_glogal_var <- 1
check_vars_exists <- function() {
  a_local_var <- 2
  assertthat::assert_that(exists("a_glogal_var")) &
    assertthat::assert_that(exists("a_local_var")) &
    assertthat::assert_that(!exists("missing_var"))
}

check_vars_exists()
```

Pythonと同様にデフォルト引数を書くこともできる。だがデフォルト引数がいつ評価されるかは、PythonでもRでも厄介な問題を生むので、個人的にはお勧めしない。以下はPythonでありがちなバグである。

```{python default_python, result="asis", class.source="python-code", class.output="python-output"}
def add(x=[]):
  x.append(1)
  return x

add()
add()
add()
```

それはさておき、Rのデフォルト引数も、見た目はPythonと同様である。

```{r default_r, class.source="r-code", class.output="r-output"}
real_to_complex <- function(real, imaginary = 0.0) {
  list(r = real, im = imaginary)
}

real_to_complex(real = 1)
real_to_complex(real = 1, imaginary = 2)
```

引数が無いことは `missing` で分かる。NULLを指定することと、引数が無いことは異なる。この例ならデフォルト引数を使っても大差ないが、引数が無いことが分かるとできることがあるかもしれない。

```{r missing_r, class.source="r-code", class.output="r-output"}
real_to_complex_alt <- function(real, imaginary) {
  im_part <- if (missing(imaginary)) {
    0
  } else {
    imaginary
  }
  list(r = real, im = im_part)
}

real_to_complex_alt(real = 1)
real_to_complex_alt(real = 1, imaginary = 2)
real_to_complex_alt(real = 1, imaginary = NULL)
```

関数のデフォルト引数の値を調べるために、Pythonでは `inspect.signature` を使う。Rでは `formals` を使う。以下は正規表現で文字列を分割する関数のデフォルト引数である。

```{python inspect_python, result="asis", class.source="python-code", class.output="python-output"}
import inspect
inspect.signature(re.split)
```

```{r inspect_r, class.source="r-code", class.output="r-output"}
formals(stringr::str_split)
```

### Assertionで実行を止める

Runtime assertion で条件を満たさないときに、処理を止めることができる。浮動小数が丸め誤差を除いて大体同じかどうかを、 `assertthat::are_equal` で許容誤差 tol (toleranceの略) を与えて比べる。

```{r are_equal_with_tol, class.source="r-code", class.output="r-output"}
assertthat::are_equal(x = 6.0, y = 6.1, tol = 0.5)
```

`assertthat::are_equal` は二つの数が大体同じかどうかを返すが、同じという条件を満たさなくても処理は止まらない。単にFALSEを返すだけである。

```{r check_if_equal_with_tol, class.source="r-code", class.output="r-output"}
check_if_equal <- function(value1, value2) {
  assertthat::are_equal(x = value1, y = value2, tol = 0.5)
}
check_if_equal(value1 = -5, value2 = 6)
```

条件を満たさないときに処理を止めたければ、 `assertthat::assert_that` を併用する。

```{r stop_if_not_equal_with_tol, error = TRUE, class.source="r-code", class.output="r-output"}
stop_if_not_equal <- function(value1, value2) {
  assertthat::assert_that(assertthat::are_equal(x = value1, y = value2, tol = 0.5))
}
stop_if_not_equal(value1 = -5, value2 = 6)
```

### コマンドライン引数を解析する

コマンドライン引数は、 `commandArgs` で文字列ベクトルとして取得する。 `trailingOnly=FALSE` にするとすべての引数、 `trailingOnly=TRUE` にすると --args および以降の引数(--argsがなければ空文字列ベクトル)を取得する。R処理系に渡す引数を無視して、Rスクリプトだけに渡す引数を取得するために、 `trailingOnly=TRUE` を使うとよい。

```{r command_args, eval=FALSE, echo=FALSE, class.source="r-code", class.output="r-output"}
commandArgs(trailingOnly = TRUE)
```

```{r launch_command_args, eval=FALSE, echo=FALSE, class.source="r-code", class.output="r-output"}
commandArgs(trailingOnly = FALSE) %>% purrr::discard(~ stringr::str_detect(.x, "\\.Rmd"))
commandArgs(trailingOnly = TRUE)
```

RStudio 上でRスクリプトを実行したときは、コマンドライン引数としてオプションを渡すことができない。対策としては、グローバル変数(仮に g_args と名付ける)があったらコマンドライン引数の代わりに扱い、そうでなければ実際のコマンドライン引数を `commandArgs` を呼び出して取得する、とすればよい。変数があるかどうかは、先ほどの `exists` を使う。

```{r delete_command_args, eval=TRUE, echo=FALSE, class.source="r-code", class.output="r-output"}
if (exists("g_args")) {
  rm(g_args)
}
```

```{r select_command_args, class.source="r-code", class.output="r-output"}
get_commandline_args <- function() {
  if (exists("g_args")) {
    g_args
  } else {
    commandArgs(trailingOnly = TRUE)
  }
}

get_commandline_args()
g_args <- c("param1", "param2")
get_commandline_args()
```

## CSVファイルを読んで集計する

Rの基本が分かったので、CSVファイルをRで読み込んで描画しよう。Rにはサンプルデータがあってそれを使うのが定番であるが、そういう描画例はウェブで多数見つかるのと、Pythonで同じデータを描画できることを目的に、横浜市のオープンデータを使用する(詳細は[データ出典](#data_source))。

本R Markdown文書にはデータを添付しないので、R MarkdownからHTMLを生成する場合は、各自ダウンロードして、 **incoming_yokohama/** サブディレクトリに置くこと。ウェブ上のデータは更新されているので、実行時期によって結果が変わるかもしれない。

|内容とリンク先|更新日|ファイル名|
|:------------------------------|:------------------------------|:------------------------------|
|[人口と世帯数の推移](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/jinko-setai-suii.html)|最新版(2020年まで)|jinkosetai-sui.csv|
|[男女別人口及び世帯数－行政区](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/suikei01.html)|令和3年12月(2021年12月)|e1yokohama2112.csv|

### ディレクトリを作る

CSVファイルを読んで集計した結果を出力するディレクトリを作る。既にディレクトリがあるならそのままにする。

```{r mkdir, class.source="r-code", class.output="r-output"}
out_dirname <- "output"
dir.create(out_dirname, showWarnings = FALSE)
assertthat::assert_that(dir.exists(out_dirname))
```

### CSVファイルを読む

`readr::read_csv` を使う。

```{r read_csv, class.source="r-code", class.output="r-output"}
library(tidyverse)
df_timeseries <- readr::read_csv("incoming_yokohama/jinkosetai-sui.csv")
```

```{r table_timeseries, echo=FALSE, class.source="r-code", class.output="r-output"}
df_timeseries %>%
  head() %>%
  to_embedded_table()
```

さて `print` で表示すると、列名に `` がついているのが分かる。

```{r print_timeseries, class.source="r-code", class.output="r-output"}
print(df_timeseries)
```

これは列名に `(` を含むので、 `$` の後に列名を書けないということである。

```{r print_timeseries_column_error, eval=TRUE, error=TRUE, results="asis", class.source="r-code", class.output="r-output"}
df_timeseries$年（和暦）
```

という風に、 `(` が上手く構文解析できないのでエラーになってしまった。構文中に埋め込む名前として使えるものを syntactic name 、そうでないものを non-syntactic name と呼ぶ。詳しい解説は[Advanced R](https://adv-r.hadley.nz/names-values.html)にあるが、ここでは間にあわせの回避策だけ述べよう。

一つ目は、列名を ` (backtick)で囲むことである。

```{r print_timeseries_column_correct, class.source="r-code", class.output="r-output"}
df_timeseries$`年（和暦）`
```

二つ目は、列名を `colnames` で付け替えることである。もちろん入力するデータを確認して、どんな形式か分かった上で、それぞれの列に対応する名前をつける。

```{r rename_timeseries_column_correct, class.source="r-code", class.output="r-output"}
colnames(df_timeseries) <- c("JPyear", "Year", "Household", "Population")
```

```{r renamed_table_timeseries, echo=FALSE, class.source="r-code", class.output="r-output"}
df_timeseries %>%
  head() %>%
  to_embedded_table()
```

### グラフを描く

まず単純なグラフを描こう。横軸を年(西暦)、縦軸を人口の折れ線グラフを描く。たった3行で済む。

```{r draw_table_timeseries, class.source="r-code", class.output="r-output"}
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population))
plot(g)
```

いろいろと見た目を変えたり、要素を付け加えることもできる。詳しくは [R for Data Science](https://r4ds.had.co.nz/data-visualisation.html)に例がたくさんある。

- X軸の刻みを10年間隔にする
- フォントを Segoe UI にして(フォントがなければデフォルトのsansフォントにする)、フォントのサイズを指定する
- 折れ線の色を青くして太くする
- タイトルをつける
- 背景を白にする
- 高さを幅の0.6倍にする

```{r make_breaks, class.source="r-code", class.output="r-output"}
year_unit <- 10
x_min <- ceiling(min(df_timeseries$Year) / year_unit) * year_unit
x_max <- floor(max(df_timeseries$Year) / year_unit) * year_unit
x_breaks <- unique(c(
  min(df_timeseries$Year),
  seq(from = x_min, to = x_max, by = year_unit), max(df_timeseries$Year)
))
x_head <- head(x_breaks, 2)
x_tail <- tail(x_breaks, 2)
x_breaks <- setdiff(
  x_breaks,
  c(x_head[2 * (diff(x_head) < year_unit)], x_tail[1 * (diff(x_tail) < year_unit)])
)
```

```{r set_font_name, message=FALSE, class.source="r-code", class.output="r-output"}
library(extrafont)
font_name <- "Segoe UI"
font_set <- extrafont::fonts()
if (is.null(font_set) || !(font_name %in% font_set)) {
  font_name <- "sans"
}
```

```{r draw_fancy_table_timeseries, message=FALSE, class.source="r-code", class.output="r-output"}
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population), color = "navy", size = 2)
g <- g + scale_x_continuous(breaks = x_breaks)
g <- g + ggtitle("Yokohama Population")
g <- g + theme_bw()
g <- g + theme(
  aspect.ratio = 0.6,
  text = element_text(family = 16),
  axis.text = element_text(family = font_name, size = 12),
  axis.title = element_text(family = font_name, size = 16),
  plot.title = element_text(family = font_name, size = 20)
)
plot(g)
```

tibbleの列名は英語にしても、図の表示は日本語にしたいということがあるだろう。 Migu 1M フォントで表示する。

```{r draw_jp_table_timeseries, class.source="r-code", class.output="r-output"}
font_name_jp <- "Migu 1M"
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population), color = "navy", size = 2)
g <- g + scale_x_continuous(breaks = x_breaks)
g <- g + ggtitle("横浜市の人口")
g <- g + xlab("年(西暦)")
g <- g + ylab("人口")
g <- g + theme_bw()
g <- g + theme(
  aspect.ratio = 0.6,
  text = element_text(family = font_name),
  axis.text = element_text(family = font_name_jp, size = 12),
  axis.title = element_text(family = font_name_jp, size = 16),
  plot.title = element_text(family = font_name_jp, size = 20)
)
plot(g)
```

`plotly::ggplotly` を使うと、インタラクティブに拡大縮小したり、線にカーソルを置いて各年の人口を表示できたりする。ただし、出力されるHTMLファイルが数Mbytes増えるのと、PDF化できなくなる。コメントアウトを外して試してほしい。

```{r plotly_jp_table_timeseries, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
library(plotly)
## plotly::ggplotly(g)
```

図をPNGファイルに保存するには、 `ggsave` を使う。 `file.path` はディレクトリ名 out_dirname と ファイル名を結合する。Pythonで `os.path.join` を使うのと同様に、 / で結合するよりも正しい作法である。

```{r ggsave_png, message=FALSE, class.source="r-code", class.output="r-output"}
png_filename <- file.path(out_dirname, "yokohama_population.png")
ggsave(png_filename, plot = g, dpi = 160)
```

図をPNGファイルに保存するために `png` と `dev.off` で囲んでもよいが、その場合は高さと幅のピクセル数を固定する必要がある。ピクセル数を指定できるのは便利だが、縦横比を変えたくないときは `ggsave` の方がよいだろう。

```{r save_png, message=FALSE, class.source="r-code", class.output="r-output"}
png(filename = png_filename, width = 800, height = 600)
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population))
plot(g)
dev.off()
```

### CSVファイルを加工する

Pandasてきに、CSVファイルを加工する方法を説明する。横浜市各区の人口を読み込む。その後、列名を英語にする。

```{r read_wards, class.source="r-code", class.output="r-output"}
df_population_data <- readr::read_csv("incoming_yokohama/e1yokohama2112.csv")
print(colnames(df_population_data))
colnames(df_population_data) <- c(
  "date", "code", "ward", "area",
  "household", "population", "male", "female",
  "per_household", "density",
  "diff_household", "diff_population"
)
```

```{r print_wards, eval=FALSE, echo=FALSE, class.source="r-code", class.output="r-output"}
## 表示すると、列が長すぎて画面からはみ出しているかもしれない。それと先頭行は区ではなく、横浜市の合計である。
df_population_data %>%
  to_embedded_table()
```

今後使いそうな列だけ残して、後は削除する。列を選ぶには `dplyr::select` を使う。 `%>%` は、コマンドラインというかシェルのパイプと同様、前段で処理したデータを後段に流す。この書き方に慣れるとRが好きになるだろう。実際には前段の返り値を後段の第一引数にしており、Pandasのメソッドチェーン(method chaining)と同じである。

```{r select_wards, class.source="r-code", class.output="r-output"}
df_population <- df_population_data %>%
  dplyr::select(c("ward", "area", "household", "population", "per_household", "density"))
```

```{r print_selected_wards, echo=FALSE, class.source="r-code", class.output="r-output"}
df_population %>%
  to_embedded_table()
```

横浜市の合計と各区を分離しよう。 `dplyr::filter` を使って、～区とそれ以外を抜き出す。 `str_end` は文字列がある文字列で終わっているかどうかをTRUEまたはFALSEで返す。Pythonの `endswith` と同じである。

```{r separate_wards, class.source="r-code", class.output="r-output"}
df_wards <- df_population %>%
  dplyr::filter(stringr::str_ends(ward, "区"))

df_whole_city <- df_population %>%
  dplyr::filter(!stringr::str_ends(ward, "区"))
```

もしくはこう書ける。

```{r separate_wards_alt, eval=FALSE, class.source="r-code", class.output="r-output"}
df_population %>% dplyr::filter(ward != "横浜市")
```

```{r print_whole_city, echo=FALSE, class.source="r-code", class.output="r-output"}
df_whole_city %>%
  to_embedded_table()
```

`dplyr::select` は列名を文字列で指定したが、 `dplyr::filter` の ward は "" が無いので文字列ではない。これは先ほど説明したシンボル(symbol)である。今回のように各区はwardという列にある、と分かっているときはこのようにハードコーディングしてよいが、実行時に文字列で与えたいことがあるだろう。そのときは `!!rlang::sym` を使う。

```{r import_rlang, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
library(rlang)
```

```{r separate_wards_again, class.source="r-code", class.output="r-output"}
ward_column_name <- "ward"
df_wards_alt <- df_population %>%
  dplyr::filter(!!rlang::sym(ward_column_name) != "横浜市")

assertthat::assert_that(identical(df_wards, df_wards_alt))
```

`rlang::expr` を使って、 `!!rlang::sym` がどう展開されたかを確認すると、先ほどのコードと同じことが分かる。

```{r separate_wards_expanded, class.source="r-code", class.output="r-output"}
rlang::expr(df_population %>%
  dplyr::filter(!!rlang::sym(ward_column_name) != "横浜市"))
```

実は dplyr 1.0.0 から `across` を使えるので、ここで `rlang::sym` を使う必要はない。後で `rlang::sym` を使う場面があるので、敢えてここで使った。

```{r separate_wards_again_across, class.source="r-code", class.output="r-output"}
df_wards_alt_across <- df_population %>%
  dplyr::filter(across(all_of(ward_column_name)) != "横浜市")
assertthat::assert_that(identical(df_wards_alt, df_wards_alt_across))
```

実は `dplyr::select` は、文字列だけでなくシンボルを受け付ける。なので "" が無くてもよかった。わざとらしい例だが、複数の文字列をシンボルにするには、 `rlang::syms` を使う。それと、 `!!` ではなく `!!!` を使う。 `!!` と `!!!` が否定の否定、否定の否定の否定、ではなく演算子というのが珍しい。

```{r select_wards_again, class.source="r-code", class.output="r-output"}
column_names <- c("ward", "area", "household", "population", "per_household", "density")
df_population_alt <- df_population_data %>%
  dplyr::select(!!!rlang::syms(column_names))
assertthat::assert_that(identical(df_population, df_population_alt))
```

### それぞれの行を集計する

df_wards には、 `1世帯当たり人員[人]` (per_household 列) と `人口密度[人/平方キロメートル]` (density 列) がある。これらは、人口 (population 列)、世帯数 (household 列)、面積 (area 列) から計算できる。 `dplyr::mutate` で実際に計算して列を作ろう。

```{r mutate_wards, class.source="r-code", class.output="r-output"}
df_wards_calc <- df_wards %>%
  dplyr::mutate(
    per_household_calc = population / household,
    density_calc = population / area
  )
```

元データの per_household と計算で求めた per_household_calc 、元データの density と計算で求めた density_calc が等しいか確認しよう。浮動小数ベクトルが丸め誤差を除いて大体同じかどうかは、 `assertthat::are_equal` で許容誤差 tol を与えて比べる。

```{r are_equal_calc, class.source="r-code", class.output="r-output"}
assertthat::assert_that(assertthat::are_equal(
  x = df_wards_calc$per_household,
  y = df_wards_calc$per_household_calc, tol = 0.01
))
assertthat::assert_that(assertthat::are_equal(
  x = df_wards_calc$density,
  y = df_wards_calc$density_calc, tol = 1.0
))
```

計算した1世帯当たり人員と人口密度があっていたようだ。

assertで条件を満たさないときに実行を停止するのではなく単に同じかどうか知りたければ、 `dplyr::near` で許容誤差 `tol` を与えて比べる。 `dplyr::near` は二つの要素を先頭から順に比較して、大体同じ=TRUE、違う=FALSEというベクトルを返す。全部TRUEかどうかは `all` で分かる。

```{r near_calc, class.source="r-code", class.output="r-output"}
are_near_values <- dplyr::near(
  x = df_wards_calc$per_household,
  y = df_wards_calc$per_household_calc, tol = 0.01
)
are_near_values
all(are_near_values)
```

```{r assert_near_calc, eval=TRUE, echo=FALSE}
assertthat::assert_that(all(are_near_values))
```

ちなみに `dplyr::mutate` の代入先もシンボルであり、実行時に文字列を与えるときは `rlang::sym` を使う。このときは `=` ではなく `:=` を使う。代入先ではなく代入元がシンボルの場合も同様である。

```{r mutate_wards_sym, class.source="r-code", class.output="r-output"}
dst_column_name <- "per_household_calc"
df_wards_calc_dst <- df_wards %>%
  dplyr::mutate(!!rlang::sym(dst_column_name) := population / household)

assertthat::assert_that(
  assertthat::are_equal(
    df_wards_calc$per_household_calc, df_wards_calc_dst$per_household_calc
  )
)

src1_column_name <- "population"
src2_column_name <- "household"
df_wards_calc_src <- df_wards %>%
  dplyr::mutate(per_household_calc :=
    !!rlang::sym(src1_column_name) / !!rlang::sym(src2_column_name))

assertthat::assert_that(
  assertthat::are_equal(df_wards_calc$per_household_calc, df_wards_calc_src$per_household_calc)
)
```

### それぞれの列を集計する

全区の世帯数と人口を足して、横浜市全体 df_whole_city と同じかどうか確かめる。 `dplyr::summarize_at` と `sum` を使って、列の全要素を足す。

```{r sum_wards, class.source="r-code", class.output="r-output"}
df_wards_sum <- df_wards_calc %>%
  dplyr::summarize_at(c("household", "population"), sum)
```

```{r print_sum_wards, echo=FALSE, class.source="r-code", class.output="r-output"}
df_wards_sum %>%
  to_embedded_table()
```

```{r verify_sum, class.source="r-code", class.output="r-output"}
assertthat::assert_that(df_whole_city$household == df_wards_sum$household)
assertthat::assert_that(df_whole_city$population == df_wards_sum$population)
```

各区の合計は市全体と一致したようだ。

ここでは世帯数と人口を足したが、それは区の名前、1世帯当たり人員、人口密度を足しても意味が無いからである。そして面積は足していなかった。列名を挙げるのがめんどくさければ、列が数字だったら足す、という操作をしたい。そういうときは、 `dplyr::summarize` と `across` を使う。1世帯当たり人員と人口密度を除いてから、数値つまり区の名前以外の列を `where(is.numeric)` で選んで足す。

```{r sum_wards_all, class.source="r-code", class.output="r-output"}
df_wards_sum_all <- df_wards %>%
  dplyr::select(-c("per_household", "density")) %>%
  dplyr::summarize(across(where(is.numeric), sum))
```

面積もあっているようだ。

```{r verify_sum_all, class.source="r-code", class.output="r-output"}
assertthat::assert_that(assertthat::are_equal(x = df_whole_city$area, y = df_wards_sum_all$area, tol = 1.0))
```

### 行をグループ化する

グループ化の例として、横浜市各区を [税務署の管轄地域](https://www.nta.go.jp/about/organization/tokyo/location/kanagawa.htm)でまとめよう。まず税務署と区の対応表を作る。

```{r tax_offices, class.source="r-code", class.output="r-output"}
tax_offices <- c(
  "神奈川", "神奈川", "鶴見", "戸塚", "戸塚", "戸塚", "保土ケ谷",
  "保土ケ谷", "保土ケ谷", "緑", "緑", "緑", "横浜中", "横浜中",
  "横浜南", "横浜南", "横浜南", "横浜南"
)
ward_names <- c(
  "神奈川区", "港北区", "鶴見区", "戸塚区", "栄区", "泉区",
  "保土ケ谷区", "旭区", "瀬谷区", "緑区", "青葉区", "都筑区", "中区", "西区",
  "南区", "磯子区", "金沢区", "港南区"
)
df_tax_offices <- tibble(tax_office = tax_offices, ward = ward_names)
```

区の名前で結合する。Rには連想配列がないが、tibbleで連想配列てきなテーブルを作ればよい。連想配列の要素を個々に引くより、 inner join や left join する方が手軽である。

```{r join_tax_offices, class.source="r-code", class.output="r-output"}
df_ward_tax_offices <- dplyr::inner_join(df_tax_offices, df_wards, by = "ward")
```

税務署ごとに世帯数と人口をまとめよう。 `dplyr::group_by` を使って、行をグループ化できる。それぞれのグループについて、列ごとにすべての行を足す。

```{r group_tax_offices, class.source="r-code", class.output="r-output"}
df_group_population <- df_ward_tax_offices %>%
  dplyr::select(c("household", "population", "tax_office")) %>%
  dplyr::group_by(tax_office) %>%
  dplyr::summarize(across(everything(), sum)) %>%
  dplyr::ungroup()
```

```{r print_group_tax_offices, echo=FALSE, class.source="r-code", class.output="r-output"}
df_group_population %>%
  to_embedded_table()
```

鶴見が少ないのは鶴見区しかないからだが、横浜中も少ない。おそらく人口の割に事業所が多いからだと予想するが、実際そうなっているか確認するのは読者への課題とする。ちなみに衆議院選挙小選挙区は区や市をまたぐので、今回の目的には使えなかった。

### カテゴリ変数

グループに用いた税務署名は文字列である。これをカテゴリ値にすることができる。Rではカテゴリをfactorと呼ぶ。 `as.factor` で文字列をカテゴリに変換する。

```{r factor_tax_offices, class.source="r-code", class.output="r-output"}
df_factor <- df_ward_tax_offices %>%
  dplyr::mutate(tax_office = as.factor(tax_office))
```

カテゴリを表示すると、見た目は文字列のままだが、実際は文字列に対応する整数を振ったものだと分かる。

```{r print_facotr_tax_offices, class.source="r-code", class.output="r-output"}
df_factor$tax_office
as.integer(df_factor$tax_office)
```

カテゴリの整数の番号を固定したいことがある。例えばグラフの凡例を描くとき、凡例はカテゴリの整数が小さい順(1, 2, ...)に表示される。 `forcats::fct_relevel` を使うと、整数の順番を固定できる。

カテゴリの順番を五十音順にしよう。つまり、神奈川(かながわ)、鶴見(つるみ)、戸塚(とつか)、保土ケ谷(ほどがや)、緑(みどり)、横浜中(よこやまなか)、横浜南(よこはまみなみ)の順にする。

```{r relevel_tax_offices, class.source="r-code", class.output="r-output"}
df_factor <- df_ward_tax_offices %>%
  dplyr::mutate(tax_office = as.factor(tax_office)) %>%
  dplyr::mutate(tax_office = forcats::fct_relevel(
    tax_office,
    c("神奈川", "鶴見", "戸塚", "保土ケ谷", "緑", "横浜中", "横浜南")
  ))
df_factor$tax_office
as.integer(df_factor$tax_office)
```

先ほどとは整数の割り当てが異なる。図にしたとき、凡例が五十音順になることを確かめよう。




```{r draw_relevel_tax_offices, class.source="r-code", class.output="r-output"}
library(RColorBrewer)
g <- ggplot(df_factor)
g <- g + geom_point(aes(x = per_household, y = density, color = tax_office), size = 4, shape = 4)
g <- g + geom_text(aes(x = per_household, y = density, label = ward),
  nudge_x = -0.03, size = 2
)
g <- g + scale_color_manual(values = brewer.pal(NROW(unique(df_factor$tax_office)), "Dark2"))
g <- g + ylim(0, 16000)
g <- g + xlab("1世帯当たり人員[人]")
g <- g + ylab("人口密度[人/平方キロメートル]")
g <- g + guides(color = guide_legend(title = "税務署"))
g <- g + theme_bw()
g <- g + theme(
  aspect.ratio = 0.8,
  text = element_text(family = font_name_jp),
  legend.position = "right",
  legend.text = element_text(family = font_name_jp, size = 16),
  legend.title = element_text(family = font_name_jp, size = 16),
  axis.text = element_text(family = font_name, size = 16),
  axis.title = element_text(family = font_name, size = 14),
  strip.text = element_text(family = font_name, size = 20),
  plot.title = element_text(family = font_name, size = 20)
)
plot(g)
```

`facet_wrap(~ tax_office, nrow=2)` と一行追加するだけで、カテゴリ別の表を作る。ggplot2すごい。

```{r facet_wrap_relevel_tax_offices, class.source="r-code", class.output="r-output"}
g <- ggplot(df_factor)
g <- g + geom_point(aes(x = per_household, y = density, color = tax_office), size = 4, shape = 4)
g <- g + geom_text(aes(x = per_household, y = density, label = ward),
  nudge_x = -0.03, size = 2
)
g <- g + scale_color_manual(values = brewer.pal(NROW(unique(df_factor$tax_office)), "Dark2"))
g <- g + ylim(0, 16000)
g <- g + xlab("1世帯当たり人員[人]")
g <- g + ylab("人口密度[人/平方キロメートル]")
g <- g + guides(color = guide_legend(title = "税務署"))
g <- g + theme_bw()
g <- g + facet_wrap(~tax_office, nrow = 2)
g <- g + theme(
  aspect.ratio = 0.8,
  text = element_text(family = font_name_jp),
  legend.position = "none",
  axis.text = element_text(family = font_name, size = 9),
  axis.title = element_text(family = font_name, size = 10),
  strip.text = element_text(family = font_name, size = 12),
  plot.title = element_text(family = font_name, size = 12)
)
plot(g)
```

### CSVファイルを出力する

`readr::write_excel_csv` を使って、BOMつきUTF-8でCSVファイルを書く。こうしておくとExcelで読める (BOMがないとExcelで読めない)。Pandasと同様、gzip形式で読み書きできる。

```{r write_group_tax_offices, class.source="r-code", class.output="r-output"}
readr::write_excel_csv(
  df_ward_tax_offices,
  file.path(out_dirname, "yokohama_tax_office.csv")
)
readr::write_excel_csv(
  df_ward_tax_offices,
  file.path(out_dirname, "yokohama_tax_office.csv.gz")
)
```

### JSONファイルを読み書きする

CSVファイルには、それがどんなデータかというメタデータを記述しづらい。メタデータをJSONファイルに書くとよいだろう。例えば横浜市と茅ヶ崎市について、このように書く。city:漢字名、kana:かな表記、roman:ローマ字表記、designated:政令指定都市かどうか、n_wards:政令指定都市なら区の数、tax_offices:所管税務署、date:最終更新日、とする。

```{r print_yokohama_json, echo=FALSE, comment="", class.source="r-code", class.output="r-output"}
cat(xfun::read_utf8("incoming_metadata/yokohama.json"), sep = "\n")
```

```{r print_chigasaki_json, echo=FALSE, comment="", class.source="r-code", class.output="r-output"}
cat(xfun::read_utf8("incoming_metadata/chigasaki.json"), sep = "\n")
```

```{r read_jsons, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
library(jsonlite)
data_yokohama <- jsonlite::fromJSON("incoming_metadata/yokohama.json")
print(data_yokohama)
data_chigasaki <- jsonlite::fromJSON("incoming_metadata/chigasaki.json")
print(data_chigasaki)
```

`class` で変数の型が分かる。

```{r class_jsons, message=FALSE, warning=FALSE, class.source="r-code", class.output="r-output"}
class(data_chigasaki)
```

JSONファイルをリストとして読み込んだことが分かる。Rにはスカラー変数が無いので、要素 (木構造の末端)はすべてベクトルである。論理型、数値、文字列型が上手く推測されたことが分かる。日付は必要なら変換しよう。

```{r json_date, class.source="r-code", class.output="r-output"}
data_yokohama$date <- lubridate::ymd(data_yokohama$date)
data_yokohama$date
class(data_yokohama$date)
```

存在しない要素を取得するとNULLが返る。エラーにはならない。茅ヶ崎市は政令指定都市ではないので、区の数はNULLである。

```{r json_elements, class.source="r-code", class.output="r-output"}
data_yokohama$n_wards
data_chigasaki$n_wards
```

JSONファイルを書き出してみる。

```{r write_jsons, class.source="r-code", class.output="r-output"}
out_json_filename <- file.path(out_dirname, "output_yokohama.json")
jsonlite::write_json(data_yokohama, path = out_json_filename, pretty = TRUE)
```

出力結果はこうなる。要素が1個でも配列になるのが、いかにもRらしい。

```{r print_out_json, echo=FALSE, comment="", class.source="r-code", class.output="r-output"}
cat(xfun::read_utf8(out_json_filename), sep = "\n")
```

## ツール

### Jupyter Notebook と R Markdown

Pythonでコードを試しながら書く場合、Jupyter Notebook を使っている方が多いだろう。Jupyter Notebook とRという組み合わせも可能である。もう一つの選択肢は、 R Markdown である。まさにこの文書の元は R Markdown で、それを直接HTMLに変換したものか、 Markdown に変換したもののHTML表示を見ているはずである。

### コードの整形と静的解析

Pythonのコードは、 autopep8 で整形して、pylint, pep8, flake8, mypy でコードの問題点を静的解析して指摘するだろう(他にもツールがあるかもしれない)。

Rは styler パッケージでコードを整形して、 lintr パッケージでコードの問題点を静的解析して指摘するとよい。 styler はRスクリプト(.Rファイル)だけでなく、R Markdown (.Rmdファイル)も整形できる。

lintr で問題点を挙げるとき、スクリプトが完成してから lintr を通すと大量の問題点を指摘されて降参しかねないので、毎日細かく通すとよい。CI (Continuous Integration) を使っているなら、毎登録 (git push) ごとにすればよい。もちろん lintr の前に、 styler で自動的に整形することもできる。

lintr よくある指摘は以下の通りである。

- Cyclomatic complexity が大きすぎる。関数が複雑すぎて、理解もテストもできないだろう。小さな関数に分割して、Cyclomatic complexity を減らす。 pylint だと、関数が長い、分岐が多いといった類似の指摘事項が出る。
- `1:NROW(aTibble)` は、aTibble が空行のときに誤動作する。代わりに `seq_len(NROW(aTibble))` を使う。このようによくある間違ったイディオムを指摘する。Pythonでは、 `range(len(anObj))` の代わりに `enumrate(anObj)` を使え、と指摘されることがある。
- ローカル変数が使われていない。似たような変数と取り違えているか、本当に使われなくなった変数が残っているかどちらかなので対処する。変数は要らなくても、その変数を返す関数呼び出しは必要かもしれない。
- 書式の良し悪し、例えば `=` の前後に空白をいれるかどうかは、 styler に任せて手作業で直さない。
- 変数名に対する指摘は、仕方ない場合もある。指摘に対応しないこともしばしばある。

### コードの論理行数

cloc パッケージで、ファイルの論理行、コメント行、空行を数えることができる。Rだけでなくさまざまなプログラミング言語に対応している。Perlが必要なので、Windows の場合は perl.exe がある場所にPATHを通しておく。ファイル名だけでなくURLを指定することもできる。[A Shiny app developed with the golem package](https://github.com/zettsu-t/nbinomPlot) にあるファイルの行数を測ろう。

```{r cloc, eval=FALSE, echo=TRUE, class.source="r-code", class.output="r-output"}
library(cloc)
cloc::cloc_pkg() %>%
  dplyr::select(all_of(c("language", "file_count", "loc", "blank_lines", "comment_lines"))) %>%
  dplyr::filter(language %in% c("R", "C++")) %>%
  to_embedded_table()
```

|language | file_count|  loc| blank_lines| comment_lines|
|:--------|----------:|----:|-----------:|-------------:|
|R        |         44| 1228|         218|           434|
|C++      |          1|   15|           2|             3|

### パッケージ化

Pythonで wheelパッケージを作成して成果物を配布できるのと同様、Rもパッケージを作成して成果物を配布できる。詳細は後述の参考文献を読んで頂くとして、RStudio の Buildタブを開いて Check ボタンを押すだけで、自作したRパッケージを検査して問題点を挙げることができる。配布するパッケージにドキュメントなどがそろっていて十分な品質かどうかを、簡単に確認できる。

## 次に進むには

最初に[データサイエンス100本ノック（構造化データ加工編）](https://github.com/The-Japan-DataScientist-Society/100knocks-preprocess)を解いて、Pythonの DataFrame と、Rの tibble の違いを覚えるとよいでしょう。

参考書としては、以下の順番が一案です。

- 最初に読むのは、「Rではじめるデータサイエンス」 (原著: [R for Data Science](https://r4ds.had.co.nz/) )
- Rをもっと使いこなすなら、「Rクックブック 第2版」 (原著: [R Cookbook 2nd Edition](https://rc2e.com/) )
- RStudioとR Markdownの使い方を学ぶなら、「再現可能性のすゝめ ―RStudioによるデータ解析とレポート作成― (Wonderful R 3)」 または、 「改訂2版 Rユーザのための RStudio［実践］入門 ―tidyverseによるモダンな分析フローの世界―」
- 「みんなのR 第2版」 (原著: R for Everyone 2nd edition)、「パーフェクトR」もよいでしょう。
- RStudioだけでなくコマンドラインを使いこなしたいなら、「バイオインフォマティクスデータスキル」 (原著: Bioinformatics Data Skills)
- プログラミング言語Rを深く知りたいなら、「R言語徹底解説」(ただし和訳は版が古い、原著: [Advanced R](https://adv-r.hadley.nz/) )。 [公式マニュアル](https://cran.r-project.org/manuals.html)より読みやすいと思います。
- Rパッケージの作成を通じて、配布可能な成果物の作り方を学びたいなら、「Rパッケージ開発入門 テスト、文書化、コード共有の手法を学ぶ」(原著 : [R packages](http://r-pkgs.had.co.nz/) )
- ブラウザから対話的に表示を変えたいなら、Shinyの使い方を学ぶ。「RとShinyで作るWebアプリケーション」を読んでから、[Mastering Shiny](https://mastering-shiny.org/)を読み、そのあと[Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/)を読むとよいでしょう。
- Rだけでは足りなくて、C++で処理を書きたいなら、 [みんなのRcpp](https://teuder.github.io/rcpp4everyone_ja/) を読んで Rcppパッケージを使います。

|書名|著者|年|出版社またはリンク|
|:--------------------------|:---------------------------------------------------------|:--------|:--------------------------|
|R for Data Science|Garrett Grolemund and Hadley Wickham|2017|https://r4ds.had.co.nz/|
|R Cookbook 2nd Edition|James (JD) Long and Paul Teetor|2019|https://rc2e.com/|
|R for Everyone 2nd edition|Jared P. Lander|2017|Addison-Wesley Professional|
|Bioinformatics Data Skills|Vince Buffalo|2015|O'Reilly Media|
|Advanced R 2nd edition|Hadley Wickham|2019|https://adv-r.hadley.nz/|
|R packages|Hadley Wickham|2015|http://r-pkgs.had.co.nz/|
|Mastering Shiny|Hadley Wickham|2020|https://mastering-shiny.org/|
|Engineering Production-Grade Shiny Apps|Colin Fay, Sébastien Rochette, Vincent Guyader and Cervan Girard|2021|https://engineering-shiny.org/|

|書名|著者|年|出版社またはリンク|
|:---------------------------------------------------------|:-------------------------------------------------|:---------|:-----------------------------|
|Rではじめるデータサイエンス|Hadley Wickham, Garrett Grolemund 著/黒川利明 訳/大橋真也 監修|2017|オライリー・ジャパン|
|Rクックブック 第2版|J.D. Long, Paul Teetor 著/大橋真也 監訳/木下哲也 訳|2020|オライリー・ジャパン|
|再現可能性のすゝめ ―RStudioによるデータ解析とレポート作成― (Wonderful R 3)|高橋康介 著/石田基広 監修/市川太祐, 高橋康介, 高柳慎一, 福島真太朗, 松浦健太郎 編|2018|共立出版|
|改訂2版 Rユーザのための RStudio［実践］入門 ―tidyverseによるモダンな分析フローの世界―|松村優哉, 湯谷啓明, 紀ノ定保礼, 前田和寛 著|2021|技術評論社|
|みんなのR 第2版|Jared P. Lander 著/高柳慎一, 津田真樹, 牧山幸史, 松村杏子, 簑田高志 監修|2018|マイナビ出版|
|パーフェクトR|Rサポーターズ 著|2017|技術評論社|
|バイオインフォマティクスデータスキル オープンソースツールを使ったロバストで再現性のある研究|Vince Buffalo 著/片山俊明, 川島秀一, 鈴木治夫, 山本泰智 監訳/酒匂寛, 山村吉信 訳|2020|オライリー・ジャパン|
|R言語徹底解説|Hadley Wickham 著/石田基広, 市川太祐, 高柳慎一, 福島真太朗 訳|2016|共立出版|
|Rパッケージ開発入門 テスト、文書化、コード共有の手法を学ぶ|Hadley Wickham 著/瀬戸山雅人, 石井弓美子, 古畠敦 訳|2016|オライリー・ジャパン|
|RとShinyで作るWebアプリケーション|梅津雄一, 中野貴広 著|2018|C&R研究所|
|みんなのRcpp|Masaki E. Tsuda 著|2020|https://teuder.github.io/rcpp4everyone_ja/|

## データ出典 {#data_source}

本 R Markdown からHTML文書やPDF文書を生成した場合、 [横浜市のオープンデータ](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/) を編集・加工したものが埋め込まれます。これらは [利用条件等](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/opendata.html) に記載の、 CC BY 4.0 に基づいています。

## その他

### 実行環境

```{r version_r, class.source="r-code", class.output="r-output"}
sessionInfo()
```

```{python version_python, class.source="python-code", class.output="python-output"}
import sys
sys.version
```

### 本文書のライセンス

本 R Markdown 文書のライセンスは、この文書がある GitHub レポジトリと同じ、MITライセンスです。いろいろコードを変えて、データや表示がどう変わるかお試しください。

```{r create_md, message=FALSE, warning=FALSE, eval=FALSE, echo=FALSE}
# RStudio の Console で実行する
rmarkdown::render("r_in_30minutes.Rmd", rmarkdown::github_document(toc = TRUE, hard_line_breaks = TRUE, pandoc_args = c("--wrap=none")))
```

```{bash create_md_command, message=FALSE, warning=FALSE, eval=FALSE, echo=FALSE}
# RStudio の Terminal で実行する
Rscript -e 'rmarkdown::render("r_in_30minutes.Rmd", rmarkdown::github_document(toc = TRUE, hard_line_breaks = TRUE, pandoc_args = c("--wrap=none")))'
```
